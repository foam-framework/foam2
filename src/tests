p({"class":"foam.nanos.test.Test","id":"Password hashing","description":"Test UserPasswordHashingDAO","server":true,"code":"import foam.nanos.auth.User;\nimport foam.nanos.auth.UserPasswordHashingDAO;\nimport foam.dao.MDAO;\nimport foam.util.SafetyUtil;\nimport foam.core.X;\nimport foam.util.Password;\n\nX context = foam.core.EmptyX.instance();\n\nuserDAO = new UserPasswordHashingDAO(context, new MDAO(User.getOwnClassInfo()));\n\nFIRST_PASSWORD = \"53CUR3P455W0RD\";\n\nuser = new User();\nuser.setDesiredPassword(FIRST_PASSWORD);\nresult = userDAO.put(user);\n\ntest(! result.getPassword().equals(FIRST_PASSWORD), \"Password returned from put should not match original password.\");\ntest(Password.verify(FIRST_PASSWORD, result.getPassword()), \"Password returned from put should be hash of original password.\");\ntest(SafetyUtil.isEmpty(result.getDesiredPassword()), \"Desired password should not be returned from first put.\");\ntest(SafetyUtil.isEmpty(result.getPreviousPassword()), \"Previous password should not be returned from first put.\");\ntest(result.getPasswordLastModified() != null, \"passwordLastModified property should be set.\");\n\nprint(\"\");\nprint(\"Second put: changing password.\");\nSECOND_PASSWORD = \"5UP3R53CUR3P455W0RD\";\nuser.setDesiredPassword(SECOND_PASSWORD);\nresult2 = userDAO.put(user);\n\ntest(! result2.getPassword().equals(SECOND_PASSWORD), \"Password returned from put should not match new password.\");\ntest(Password.verify(SECOND_PASSWORD, result2.getPassword()), \"Password returned from put should be hash of new password.\");\ntest(SafetyUtil.isEmpty(result2.getDesiredPassword()), \"Desired password should not be returned from second put.\");\ntest(! SafetyUtil.isEmpty(result2.getPreviousPassword()), \"Previous password should be returned from second put.\");\ntest(Password.verify(FIRST_PASSWORD, result2.getPreviousPassword()), \"Previous password returned from put should be hash of original password.\");\ntest(result2.getPasswordLastModified().compareTo(result.getPasswordLastModified()) > 0, \"passwordLastModified property should be updated.\");","notes":""})
p({"class":"foam.nanos.test.Test","id":"MDAO test","description":"MDAO test","server":true,"scheduled":false,"code":"mdao = new foam.dao.MDAO(foam.nanos.auth.Country.getOwnClassInfo());\ncountry = new foam.nanos.auth.Country();\ncountry.setCode(\"CN\");\ncountry.setName(\"CHINA\");\nmdao.put(country);\ncountry = country.fclone();\ncountry.setCode(\"CA\");\ncountry.setName(\"CANADA\");\nmdao.put(country);\ncountry = country.fclone();\ncountry.setCode(\"USA\");\ncountry.setName(\"United States of America\");\nmdao.put(country);\nresult = mdao.find(\"CA\");\ntest(result.getName().equals(\"CANADA\"),\"test if country name of CA is CANADA?\");\nresult = mdao.find(\"CAD\");\ntest(result==null,\"test if country name of CAD not found?\");","output":"SUCCESS: test if country name of CA is CANADA?\nSUCCESS: test if country name of CAD not found?\n","notes":""})
p({"class":"foam.nanos.test.Test","id":"MapDAOTest","description":"MapDAOTest","server":true,"scheduled":false,"code":"mdao = new foam.dao.MapDAO(foam.nanos.auth.Country.getOwnClassInfo());\ncountry  = new foam.nanos.auth.Country();\ncountry.setCode(\"CN\");\ncountry.setName(\"CHINA\");\nmdao.put(country);\ncountry=country.fclone();\ncountry.setCode(\"CN2\");\ncountry.setName(\"CHINA2\");\nmdao.put(country);\nresult = mdao.find(\"CN\");\ntest(result.getName().equals(\"CHINA\"),\"test if country name of CN is CHINA?\");\nresult = mdao.find(\"CAD\");\ntest(result==null,\"test if country name of CAD not found?\");\n\n","notes":""})
p({"class":"foam.nanos.test.Test","id":"Relationship Test","description":"Tests behaviour of relationships from Java","lastRun":"2018-02-13T17:21:26.173Z","lastDuration":28,"code":"//set up\nfoam.core.X x = foam.core.EmptyX.instance();\n\nx = x.put(\"courseDAO\", new foam.dao.EasyDAO.Builder(x).\nsetContextualize(true).\nsetAuthenticate(false).\nsetOf(foam.nanos.demo.relationship.Course.getOwnClassInfo()).\nbuild());\n\nx = x.put(\"professorDAO\", new foam.dao.EasyDAO.Builder(x).\nsetGuid(true).\nsetContextualize(true).\nsetAuthenticate(false).\nsetOf(foam.nanos.demo.relationship.Professor.getOwnClassInfo()).\nbuild());\n\nx = x.put(\"studentDAO\", new foam.dao.EasyDAO.Builder(x).\nsetContextualize(true).\nsetAuthenticate(false).\nsetSeqNo(true).\nsetOf(foam.nanos.demo.relationship.Student.getOwnClassInfo()).\nbuild());\n\nx = x.put(\"studentCourseJunctionDAO\", new foam.dao.EasyDAO.Builder(x).\nsetContextualize(true).\nsetAuthenticate(false).\nsetOf(foam.nanos.demo.relationship.StudentCourseJunction.getOwnClassInfo()).\nbuild());\n\nfoam.dao.DAO studentDAO               = ((foam.dao.DAO)x.get(\"studentDAO\")).inX(x);\nfoam.dao.DAO courseDAO                = ((foam.dao.DAO)x.get(\"courseDAO\")).inX(x);\nfoam.dao.DAO professorDAO             = ((foam.dao.DAO)x.get(\"professorDAO\")).inX(x);\nfoam.dao.DAO studentCourseJunctionDAO = ((foam.dao.DAO)x.get(\"studentCourseJunctionDAO\")).inX(x);\n\nstudentDAO.put(new foam.nanos.demo.relationship.Student.Builder(x).\nsetName(\"Adam\").\nbuild());\n\nstudentDAO.put(new foam.nanos.demo.relationship.Student.Builder(x).\nsetName(\"Mike\").\nbuild());\n\ncourseDAO.put(new foam.nanos.demo.relationship.Course.Builder(x).\nsetCode(\"CS 101\").\nsetTitle(\"Intro to computer science\").\nbuild());\n\ncourseDAO.put(new foam.nanos.demo.relationship.Course.Builder(x).\nsetCode(\"CS 201\").\nsetTitle(\"Intro to computer science II\").\nbuild());\n\nfoam.nanos.demo.relationship.Professor donald =\n(foam.nanos.demo.relationship.Professor) professorDAO.put(new foam.nanos.demo.relationship.Professor.Builder(x).\nsetName(\"Donald Knuth\").\nbuild());\n\nfoam.nanos.demo.relationship.Professor alan =\n(foam.nanos.demo.relationship.Professor)professorDAO.put(new foam.nanos.demo.relationship.Professor.Builder(x).\nsetName(\"Alan Kay\").\nbuild());\n\n\n\nfoam.nanos.demo.relationship.Student adam = (foam.nanos.demo.relationship.Student)studentDAO.find(1L);\nfoam.nanos.demo.relationship.Student mike = (foam.nanos.demo.relationship.Student)studentDAO.find(2L);\n\nfoam.nanos.demo.relationship.Course cs101 = (foam.nanos.demo.relationship.Course)courseDAO.find(\"CS 101\");\nfoam.nanos.demo.relationship.Course cs201 = (foam.nanos.demo.relationship.Course)courseDAO.find(\"CS 201\");\n\n\n// Assign professors\n// TODO: should we support .add()/.remove() for 1:* relationships as\n// well?\ndonald.getCourses(x).put(cs101);\nalan.getCourses(x).put(cs201);\n\n// Enroll students\ncs101.getStudents(x).add(adam);\nmike.getCourses(x).add(cs201);\nmike.getCourses(x).add(cs101);\n\nfoam.nanos.demo.relationship.Course course = cs101;\n\ntest(course.findProfessor(x).getName() == \"Donald Knuth\", \"Getting Target Object from Source Object (1:*)\");\n\ndonaldsCourses = donald.getCourses(x).select(new foam.dao.ArraySink()).getArray();\n\ntest(donaldsCourses.get(0).getCode() == \"CS 101\", \"Getting Source Object from target Object (1:*)\");\n\nstudents = course.getStudents(x).getDAO().select(new foam.dao.ArraySink()).getArray();\n\ntest(students.size() == 2, \"(length check) Getting Source object from target Object (*:*)\");\n\ntest(students.get(0).getName() == \"Adam\", \"(Object check) Getting Source object from target Object (*:*)\");\n\nadamsCourses = adam.getCourses(x).getDAO().select(new foam.dao.ArraySink()).getArray();\n\ntest(adamsCourses.size() == 1, \"(length check) Getting Target object from Source Object (*:*)\");\n\ntest(adamsCourses.get(0).getCode() == \"CS 101\", \"(Object check) Getting Target object from Source Object (*:*)\");\n\nmikesCourses = mike.getCourses(x).getDAO().select(new foam.dao.ArraySink()).getArray();\n\ntest(mikesCourses.size() == 2, \"(length check) multiple sources *:*\");\n\ncontainsCourses = true;\n\nArrayList courseCodes = new ArrayList();\ncourseCodes.add(\"CS 101\");\ncourseCodes.add(\"CS 201\");\n\nfor(course : mikesCourses) {\ncode = course.getCode();\ncontainsCourses = containsCourses && courseCodes.contains(code);\n}\n\ntest(containsCourses, \"(Object check) multiple sources *:*\");\n\ncourse = cs201;\n\nprint(\"\");\nprint(\"**** \" + course.getCode() + \" ****\");\nprint(\"Instructor: \" + ((foam.nanos.demo.relationship.Professor)((foam.dao.DAO)x.get(\"professorDAO\")).find(course.getProfessor())).getName());\nprint(\"\");\nprint(\"*** Students ***\");\nprint(\"\");\n\nsink = (foam.dao.ArraySink)course.getStudents(x).getDAO().select(null);\ni = sink.getArray().iterator();\n\nwhile ( i.hasNext() ) {\nfoam.nanos.demo.relationship.Student student = (foam.nanos.demo.relationship.Student)i.next();\nprint(student.getName());\n}\n\nfoam.nanos.demo.relationship.Professor professor = alan;\n\nprint(\"\");\nprint(\"**** \" + professor.getName() + \" ****\");\nprint(\"*** Courses ***\");\nprint(\"\");\n\nsink = (foam.dao.ArraySink)professor.getCourses(x).select(null);\ni = sink.getArray().iterator();\n\nwhile ( i.hasNext() ) {\nfoam.nanos.demo.relationship.Course course = (foam.nanos.demo.relationship.Course)i.next();\nprint(course.getCode());\n}\n\n\nprofessor = donald;\n\nprint(\"\");\nprint(\"**** \" + professor.getName() + \" ****\");\nprint(\"*** Courses ***\");\nprint(\"\");\n\nsink = (foam.dao.ArraySink)professor.getCourses(x).select(null);\ni = sink.getArray().iterator();\n\nwhile ( i.hasNext() ) {\nfoam.nanos.demo.relationship.Course course = (foam.nanos.demo.relationship.Course)i.next();\nprint(course.getCode());\n}\n"})
p({"class":"foam.nanos.test.Test","id":"Freeze test","code":"foam.nanos.demo.relationship.Professor prof = new foam.nanos.demo.relationship.Professor();\n\nprof.setName(\"Adam\");\n\nprint(\"Name is: \" + prof.getName());\nprint(\"Freezing object.\");\n\nprof.freeze();\n\nboolean exceptionThrown = false;\n\ntry {\n  prof.setName(\"Bob\");\n} catch ( UnsupportedOperationException ex ) {\n  exceptionThrown = true;\n}\n\ntest(exceptionThrown, \"Prevented setting property of frozen object.\");\ntest(prof.getName().equals(\"Adam\"), \"Name is still Adam\");\n\nfoam.nanos.demo.relationship.Professor prof2 = prof.fclone();\n\nprint(\"Unfreezing object via cloning\");\n\nprint(\"Name was: \" + prof2.getName());\n\nprof2.setName(\"Bob\");\n\nprint(\"Name is now: \" + prof2.getName());\n\nfoam.core.X x = foam.core.EmptyX.instance();\n\nx = x.put(\"professorDAO\", new foam.dao.EasyDAO.Builder(x).\nsetGuid(true).\nsetContextualize(true).\nsetAuthenticate(false).\nsetOf(foam.nanos.demo.relationship.Professor.getOwnClassInfo()).\nbuild());\n\nfoam.dao.DAO professorDAO = ((foam.dao.DAO)x.get(\"professorDAO\"));\n\nprofessorDAO.put(prof2);\n\nfoam.dao.ArraySink sink = (foam.dao.ArraySink)professorDAO.select();\n\nprof = (foam.nanos.demo.relationship.Professor)sink.getArray().get(0);\n\nprint(\"Testing if object from DAO is frozen.\");\n\nString name1 = prof.getName();\n\nprint(\"Name is: \" + prof.getName());\n\nexceptionThrown = false;\n\ntry {\n  prof.setName(\"John\");\n} catch ( UnsupportedOperationException ex ) {\n  exceptionThrown = true;\n}\n\ntest(exceptionThrown, \"Prevented setting property of frozen object.\");\ntest(prof.getName().equals(name1), \"Name is still \" + name1);\n"})
p({"class":"foam.dao.SequenceNumberDAOTest","id":"SequenceNumberDAO test","description":"SequenceNumberDAO tests"})
p({"class":"foam.nanos.ruler.test.RulerDAOTest","id":"RulerDAOTest","description":"Rule engine test"})
p({"class":"foam.nanos.test.Test","id":"PromisedDAO Test","status":2,"code":"promisedDAO = new foam.dao.PromisedDAO.Builder(x)\n  .setOf(foam.nanos.auth.Country.getOwnClassInfo())\n  .build();\n\nnew Thread() {\n  public void run() {\n    mdao = new foam.dao.MDAO(foam.nanos.auth.Country.getOwnClassInfo());\n    country = new foam.nanos.auth.Country();\n    country.setCode(\"CN\");\n    country.setName(\"CHINA\");\n    mdao.put(country);\n    promisedDAO.setPromise(mdao);\n  }\n}.start();\n\ntest(promisedDAO.select().getArray().size() == 1, \"DAO has 1 element\");"})
p({"class":"foam.nanos.test.Test","id":"PromisedDAO Test","passed":1,"lastRun":"2019-02-09T16:45:22.301Z","lastDuration":65,"status":1,"output":"SUCCESS: DAO has 1 element\n"})
p({"class":"foam.nanos.test.Test","id":"Freeze test","status":2})
p({"class":"foam.nanos.test.Test","id":"MDAO test","status":2,"output":""})
p({"class":"foam.nanos.test.Test","id":"Password hashing","status":2})
p({"class":"foam.nanos.test.Test","id":"PromisedDAO Test","status":2,"output":""})
p({"class":"foam.nanos.test.Test","id":"MapDAOTest","status":2})
p({"class":"foam.nanos.test.Test","id":"Relationship Test","status":2})
p({"class":"foam.nanos.test.Test","id":"MDAO test","passed":2,"lastRun":"2019-02-09T16:45:41.973Z","lastDuration":86,"status":1,"output":"SUCCESS: test if country name of CA is CANADA?\nSUCCESS: test if country name of CAD not found?\n"})
p({"class":"foam.nanos.test.Test","id":"Freeze test","passed":4,"lastRun":"2019-02-09T16:45:41.990Z","lastDuration":104,"status":1,"output":"Name is: Adam\nFreezing object.\nSUCCESS: Prevented setting property of frozen object.\nSUCCESS: Name is still Adam\nUnfreezing object via cloning\nName was: Adam\nName is now: Bob\nTesting if object from DAO is frozen.\nName is: Bob\nSUCCESS: Prevented setting property of frozen object.\nSUCCESS: Name is still Bob\n"})
p({"class":"foam.dao.SequenceNumberDAOTest","id":"SequenceNumberDAO test","status":2})
p({"class":"foam.dao.SequenceNumberDAOTest","id":"SequenceNumberDAO test","passed":7,"lastRun":"2019-02-09T16:45:42.006Z","lastDuration":3,"status":1,"output":"\nSUCCESS: Sequence number value equals 1 before putting to DAO.\nSUCCESS: User id equals 1\nSUCCESS: Sequence number value equals 2 after putting to DAO.\nSUCCESS: Sequence number value equals 1 before putting to DAO.\nSUCCESS: User id equals 1000\nSUCCESS: Sequence number value equals 1001 after putting to DAO.\nSUCCESS: Sequence number value equals 5001 after initializing."})
p({"class":"foam.nanos.test.Test","id":"MapDAOTest","passed":2,"lastRun":"2019-02-09T16:45:42.044Z","lastDuration":95,"status":1,"output":"SUCCESS: test if country name of CN is CHINA?\nSUCCESS: test if country name of CAD not found?\n"})
p({"class":"foam.nanos.test.Test","id":"PromisedDAO Test","lastRun":"2019-02-09T16:45:42.058Z","lastDuration":115,"status":1,"output":"SUCCESS: DAO has 1 element\n"})
p({"class":"foam.nanos.test.Test","id":"Relationship Test","passed":8,"lastRun":"2019-02-09T16:45:42.120Z","lastDuration":141,"status":1,"output":"SUCCESS: Getting Target Object from Source Object (1:*)\nSUCCESS: Getting Source Object from target Object (1:*)\nSUCCESS: (length check) Getting Source object from target Object (*:*)\nSUCCESS: (Object check) Getting Source object from target Object (*:*)\nSUCCESS: (length check) Getting Target object from Source Object (*:*)\nSUCCESS: (Object check) Getting Target object from Source Object (*:*)\nSUCCESS: (length check) multiple sources *:*\nSUCCESS: (Object check) multiple sources *:*\n\n**** CS 201 ****\nInstructor: Alan Kay\n\n*** Students ***\n\nMike\n\n**** Alan Kay ****\n*** Courses ***\n\nCS 201\n\n**** Donald Knuth ****\n*** Courses ***\n\nCS 101\n"})
p({"class":"foam.nanos.test.Test","id":"Password hashing","passed":11,"lastRun":"2019-02-09T16:45:42.672Z","lastDuration":731,"status":1,"output":"SUCCESS: Password returned from put should not match original password.\nSUCCESS: Password returned from put should be hash of original password.\nSUCCESS: Desired password should not be returned from first put.\nSUCCESS: Previous password should not be returned from first put.\nSUCCESS: passwordLastModified property should be set.\n\nSecond put: changing password.\nSUCCESS: Password returned from put should not match new password.\nSUCCESS: Password returned from put should be hash of new password.\nSUCCESS: Desired password should not be returned from second put.\nSUCCESS: Previous password should be returned from second put.\nSUCCESS: Previous password returned from put should be hash of original password.\nSUCCESS: passwordLastModified property should be updated.\n"})
p({"class":"foam.nanos.test.Test","id":"MapDAOTest","status":2,"output":""})
p({"class":"foam.nanos.test.Test","id":"Password hashing","status":2,"output":""})
p({"class":"foam.nanos.test.Test","id":"Relationship Test","status":2,"output":""})
p({"class":"foam.nanos.test.Test","id":"Freeze test","status":2,"output":""})
p({"class":"foam.nanos.test.Test","id":"PromisedDAO Test","status":2,"output":""})
p({"class":"foam.nanos.test.Test","id":"MDAO test","status":2,"output":""})
p({"class":"foam.nanos.test.Test","id":"MDAO test","lastRun":"2019-02-09T16:59:12.860Z","lastDuration":26,"status":1,"output":"SUCCESS: test if country name of CA is CANADA?\nSUCCESS: test if country name of CAD not found?\n"})
p({"class":"foam.nanos.test.Test","id":"MapDAOTest","lastRun":"2019-02-09T16:59:12.893Z","lastDuration":59,"status":1,"output":"SUCCESS: test if country name of CN is CHINA?\nSUCCESS: test if country name of CAD not found?\n"})
p({"class":"foam.dao.SequenceNumberDAOTest","id":"SequenceNumberDAO test","status":2,"output":""})
p({"class":"foam.dao.SequenceNumberDAOTest","id":"SequenceNumberDAO test","lastRun":"2019-02-09T16:59:12.906Z","lastDuration":2,"status":1,"output":"\nSUCCESS: Sequence number value equals 1 before putting to DAO.\nSUCCESS: User id equals 1\nSUCCESS: Sequence number value equals 2 after putting to DAO.\nSUCCESS: Sequence number value equals 1 before putting to DAO.\nSUCCESS: User id equals 1000\nSUCCESS: Sequence number value equals 1001 after putting to DAO.\nSUCCESS: Sequence number value equals 5001 after initializing."})
p({"class":"foam.nanos.test.Test","id":"Freeze test","lastRun":"2019-02-09T16:59:12.955Z","lastDuration":120,"status":1,"output":"Name is: Adam\nFreezing object.\nSUCCESS: Prevented setting property of frozen object.\nSUCCESS: Name is still Adam\nUnfreezing object via cloning\nName was: Adam\nName is now: Bob\nTesting if object from DAO is frozen.\nName is: Bob\nSUCCESS: Prevented setting property of frozen object.\nSUCCESS: Name is still Bob\n"})
p({"class":"foam.nanos.test.Test","id":"PromisedDAO Test","lastRun":"2019-02-09T16:59:13.012Z","lastDuration":175,"status":1,"output":"SUCCESS: DAO has 1 element\n"})
p({"class":"foam.nanos.test.Test","id":"Relationship Test","lastRun":"2019-02-09T16:59:13.128Z","lastDuration":294,"status":1,"output":"SUCCESS: Getting Target Object from Source Object (1:*)\nSUCCESS: Getting Source Object from target Object (1:*)\nSUCCESS: (length check) Getting Source object from target Object (*:*)\nSUCCESS: (Object check) Getting Source object from target Object (*:*)\nSUCCESS: (length check) Getting Target object from Source Object (*:*)\nSUCCESS: (Object check) Getting Target object from Source Object (*:*)\nSUCCESS: (length check) multiple sources *:*\nSUCCESS: (Object check) multiple sources *:*\n\n**** CS 201 ****\nInstructor: Alan Kay\n\n*** Students ***\n\nMike\n\n**** Alan Kay ****\n*** Courses ***\n\nCS 201\n\n**** Donald Knuth ****\n*** Courses ***\n\nCS 101\n"})
p({"class":"foam.nanos.test.Test","id":"Password hashing","lastRun":"2019-02-09T16:59:13.503Z","lastDuration":669,"status":1,"output":"SUCCESS: Password returned from put should not match original password.\nSUCCESS: Password returned from put should be hash of original password.\nSUCCESS: Desired password should not be returned from first put.\nSUCCESS: Previous password should not be returned from first put.\nSUCCESS: passwordLastModified property should be set.\n\nSecond put: changing password.\nSUCCESS: Password returned from put should not match new password.\nSUCCESS: Password returned from put should be hash of new password.\nSUCCESS: Desired password should not be returned from second put.\nSUCCESS: Previous password should be returned from second put.\nSUCCESS: Previous password returned from put should be hash of original password.\nSUCCESS: passwordLastModified property should be updated.\n"})
p({"class":"foam.nanos.test.Test","id":"e2e-json-serialization-test","description":"End to End JSON Serialization Test","server":false,"code":"var jsonParser = foam.json.Parser.create({ strict: true });\n\nvar initialObject = foam.test.AllSerializableProperties.createPopulated();\n\nvar jsSerialized = foam.json.Network.stringify(initialObject);\n\nlog(\"JS Serialization: \", jsSerialized);\n\nvar afterJSSerialization = jsonParser.parseString(jsSerialized);\n\ntest(foam.util.equals(initialObject, afterJSSerialization), \"After JS Serialization object is still equivalent.\");\n\nx[\"serializationTestEchoService\"].echo(afterJSSerialization).then(function(afterJavaSerialization) {\n  var diff = initialObject.diff(afterJavaSerialization);\n  for ( var keys = Object.keys(diff), i = 0, key ; key = keys[i++] ; ) {\n    log(\"Differs on property \", key, \": \", diff[key]);\n  }\n  test(foam.util.equals(initialObject, afterJavaSerialization), \"After Java Serialization object is still equivalent.\");\n});\n"})
p({"class":"foam.nanos.test.Test","id":"e2e-json-serialization-test","passed":2,"lastRun":"2019-04-30T21:06:54.403Z","lastDuration":146,"status":2,"output":"JS Serialization: {\"class\":\"foam.test.AllSerializableProperties\",\"intProp\":12,\"stringProp\":\"asdf\",\"fObjectArrayProp\":[{\"description\":\"An object in an array!\"},{\"description\":\"Another object in an array!\"}],\"objectProp\":[1,\"foo\",{\"class\":\"__Timestamp__\",\"value\":\"2019-04-30T21:06:54.291Z\"},{\"class\":\"__Class__\",\"forClass_\":\"foam.test.AllSerializableProperties\"},[3,4]],\"classProp\":{\"class\":\"__Class__\",\"forClass_\":\"foam.test.AllProperties\"},\"fObjectPropertyProp\":{\"description\":\"some object\"},\"emailProp\":\"test@example.com\",\"enumProp\":1,\"dateProp\":819188640000,\"dateTimeProp\":819278624000,\"floatProp\":1.2345,\"longProp\":12341234,\"currencyProp\":342342,\"colorProp\":\"rgba(0, 0, 255, 0)\",\"mapProp\":{},\"imageProp\":\"/favicon/favicon-32x32.png\",\"urlProp\":\"https://google.com/\",\"passwordProp\":\"superSecret111!\",\"phoneNumberProp\":\"555-3455\"}\nSUCCESS: After JS Serialization object is still equivalent.\nSUCCESS: After Java Serialization object is still equivalent.\n"})
p({"class":"foam.nanos.test.Test","id":"e2e-json-serialization-test","status":1})
p({"class":"foam.nanos.test.Test","id":"json-outputter-copy-from-test","server":false,"code":"var outputter = foam.json.Outputter.create().copyFrom(foam.json.Network);\n\ntest(foam.util.equals(outputter, foam.json.Network), \"JSON Outputter should set properties correctly when copying from other JSON Outputter object.\");"})
p({"class":"foam.nanos.test.Test","passed":10,"failed":0,"id":"FoldAndReduceTest","description":"A test for the FoldManager and ReduceManager","lastRun":"2019-06-16T14:08:13.968Z","lastDuration":136,"status":1,"code":"import foam.nanos.test.StockSnapshot;\nimport foam.nanos.analytics.Candlestick;\nimport static foam.mlang.MLang.*;\n\n// Setup:\n\nhourly = 60 * 60 * 1000;\ndaily = 24 * 60 * 60 * 1000;\nweekly = 7 * 24 * 60 * 60 * 1000;\n\nhourlyDAO = new foam.dao.MDAO(Candlestick.getOwnClassInfo());\ndailyDAO = new foam.dao.MDAO(Candlestick.getOwnClassInfo());\nweeklyDAO = new foam.dao.MDAO(Candlestick.getOwnClassInfo());\n\nfm = new foam.nanos.analytics.DAOFoldManager.Builder(x)\n    .setDao(hourlyDAO)\n    .setPeriodLengthMs(hourly)\n    .build();\n\nstockDAO = new foam.nanos.analytics.FoldManagerDAODecorator.Builder(x)\n    .setDelegate(new foam.dao.MDAO(StockSnapshot.getOwnClassInfo()))\n    .setFm(fm)\n    .build();\n\ndailyRm = new foam.nanos.analytics.DAOReduceManager.Builder(x)\n    .setSourceDAO(hourlyDAO)\n    .setDestDAO(dailyDAO)\n    .setPeriodLengthMs(daily)\n    .build();\n\nweeklyRm = new foam.nanos.analytics.DAOReduceManager.Builder(x)\n    .setSourceDAO(dailyDAO)\n    .setDestDAO(weeklyDAO)\n    .setPeriodLengthMs(weekly)\n    .build();\n    \n// Test data:\n    \n// First hour.\nstockDAO.put(new StockSnapshot.Builder(x)\n    .setSymbol(\"TSLA\")\n    .setTime(new Date(5))\n    .setPrice(500)\n    .build());\nstockDAO.put(new StockSnapshot.Builder(x)\n    .setSymbol(\"TSLA\")\n    .setTime(new Date(10))\n    .setPrice(650)\n    .build());\nstockDAO.put(new StockSnapshot.Builder(x)\n    .setSymbol(\"TSLA\")\n    .setTime(new Date(20))\n    .setPrice(600)\n    .build());\n\n// Second hour.\nstockDAO.put(new StockSnapshot.Builder(x)\n    .setSymbol(\"TSLA\")\n    .setTime(new Date(hourly + 5))\n    .setPrice(1000)\n    .build());\nstockDAO.put(new StockSnapshot.Builder(x)\n    .setSymbol(\"TSLA\")\n    .setTime(new Date(hourly + 10))\n    .setPrice(2000)\n    .build());\nstockDAO.put(new StockSnapshot.Builder(x)\n    .setSymbol(\"TSLA\")\n    .setTime(new Date(hourly + 20))\n    .setPrice(3000)\n    .build());\n\n// Second day.\nstockDAO.put(new StockSnapshot.Builder(x)\n    .setSymbol(\"TSLA\")\n    .setTime(new Date(daily + 5))\n    .setPrice(300)\n    .build());\nstockDAO.put(new StockSnapshot.Builder(x)\n    .setSymbol(\"TSLA\")\n    .setTime(new Date(daily+ 10))\n    .setPrice(100)\n    .build());\nstockDAO.put(new StockSnapshot.Builder(x)\n    .setSymbol(\"TSLA\")\n    .setTime(new Date(daily + 20))\n    .setPrice(200)\n    .build());\n\ntest(stockDAO.select(COUNT()).getValue() == 9,\n    \"Stock DAO has expected number of items\");\n    \nprint(\"\");\nprint(\"Hourly data validation\");\n\nhourlyData = hourlyDAO.orderBy(Candlestick.OPEN_TIME).select().getArray();\ntest(hourlyData.size() == 3,\n    \"Hourly DAO has expected number of items\");\n\nexpected = new Candlestick.Builder(x)\n    .setKey(\"TSLA\")\n    .setOpenTime(new Date(0))\n    .setCloseTime(new Date(hourly - 1))\n    .setOpen(500)\n    .setOpenValueTime(new Date(5))\n    .setClose(600)\n    .setCloseValueTime(new Date(20))\n    .setTotal(1750)\n    .setMin(500)\n    .setMax(650)\n    .setCount(3)\n    .build();\n\ndiff = expected.diff(hourlyData.get(0));\ntest(diff.keySet().size() == 0,\n    diff.keySet() + \" fields are set incorrectly\");\n\nexpected = new Candlestick.Builder(x)\n    .setKey(\"TSLA\")\n    .setOpenTime(new Date(hourly))\n    .setCloseTime(new Date(hourly*2 - 1))\n    .setOpen(1000)\n    .setOpenValueTime(new Date(hourly+5))\n    .setClose(3000)\n    .setCloseValueTime(new Date(hourly+20))\n    .setTotal(6000)\n    .setMin(1000)\n    .setMax(3000)\n    .setCount(3)\n    .build();\n\ndiff = expected.diff(hourlyData.get(1));\ntest(diff.keySet().size() == 0,\n    diff.keySet() + \" fields are set incorrectly\");\n\nexpected = new Candlestick.Builder(x)\n    .setKey(\"TSLA\")\n    .setOpenTime(new Date(daily))\n    .setCloseTime(new Date(daily + hourly - 1))\n    .setOpen(300)\n    .setOpenValueTime(new Date(daily+5))\n    .setClose(200)\n    .setCloseValueTime(new Date(daily+20))\n    .setTotal(600)\n    .setMin(100)\n    .setMax(300)\n    .setCount(3)\n    .build();\n\ndiff = expected.diff(hourlyData.get(2));\ntest(diff.keySet().size() == 0,\n    diff.keySet() + \" fields are set incorrectly\");\n    \nprint(\"\");\nprint(\"Daily data validation\");\n\ndailyRm.doReduce();\n\ndailyData = dailyDAO.orderBy(Candlestick.OPEN_TIME).select().getArray();\ntest(dailyData.size() == 2,\n    \"Daily DAO has expected number of items\");\n\nexpected = new Candlestick.Builder(x)\n    .setKey(\"TSLA\")\n    .setOpenTime(new Date(0))\n    .setCloseTime(new Date(daily - 1))\n    .setOpen(500)\n    .setOpenValueTime(new Date(5))\n    .setClose(3000)\n    .setCloseValueTime(new Date(hourly+20))\n    .setTotal(7750)\n    .setMin(500)\n    .setMax(3000)\n    .setCount(6)\n    .build();\n\ndiff = expected.diff(dailyData.get(0));\ntest(diff.keySet().size() == 0,\n    diff.keySet() + \" fields are set incorrectly\");\n\nexpected = new Candlestick.Builder(x)\n    .setKey(\"TSLA\")\n    .setOpenTime(new Date(daily))\n    .setCloseTime(new Date(daily*2 - 1))\n    .setOpen(300)\n    .setOpenValueTime(new Date(daily+5))\n    .setClose(200)\n    .setCloseValueTime(new Date(daily+20))\n    .setTotal(600)\n    .setMin(100)\n    .setMax(300)\n    .setCount(3)\n    .build();\n\ndiff = expected.diff(dailyData.get(1));\ntest(diff.keySet().size() == 0,\n    diff.keySet() + \" fields are set incorrectly\");\n    \nprint(\"\");\nprint(\"Weekly data validation\");\n\nweeklyRm.doReduce();\n\nweeklyData = weeklyDAO.orderBy(Candlestick.OPEN_TIME).select().getArray();\ntest(weeklyData.size() == 1,\n    \"weekly DAO has expected number of items\");\n\nexpected = new Candlestick.Builder(x)\n    .setKey(\"TSLA\")\n    .setOpenTime(new Date(0))\n    .setCloseTime(new Date(weekly - 1))\n    .setOpen(500)\n    .setOpenValueTime(new Date(5))\n    .setClose(200)\n    .setCloseValueTime(new Date(daily+20))\n    .setTotal(8350)\n    .setMin(100)\n    .setMax(3000)\n    .setCount(9)\n    .build();\n\ndiff = expected.diff(weeklyData.get(0));\ntest(diff.keySet().size() == 0,\n    diff.keySet() + \" fields are set incorrectly\");\n\nprint(\"Done\");","output":"SUCCESS: Stock DAO has expected number of items\n\nHourly data validation\nSUCCESS: Hourly DAO has expected number of items\nSUCCESS: [] fields are set incorrectly\nSUCCESS: [] fields are set incorrectly\nSUCCESS: [] fields are set incorrectly\n\nDaily data validation\nSUCCESS: Daily DAO has expected number of items\nSUCCESS: [] fields are set incorrectly\nSUCCESS: [] fields are set incorrectly\n\nWeekly data validation\nSUCCESS: weekly DAO has expected number of items\nSUCCESS: [] fields are set incorrectly\nDone\n"})
p({"class":"foam.nanos.test.Test","passed":4,"failed":0,"id":"PlotTest","lastRun":"2019-05-03T02:50:41.133Z","lastDuration":3,"server":false,"status":2,"code":"var Candlestick = foam.nanos.analytics.Candlestick;\nvar dao = foam.dao.MDAO.create({of: Candlestick});\nPromise.all([\n    {\n        key: 'C1',\n        count: 1,\n        total: 100,\n        closeTime: new Date(0)\n    },\n    {\n        key: 'C1',\n        count: 1,\n        total: 200,\n        closeTime: new Date(5)\n    },\n    {\n        key: 'C2',\n        count: 1,\n        total: 100,\n        closeTime: new Date(0)\n    },\n    {\n        key: 'C1',\n        count: 1,\n        total: 190,\n        closeTime: new Date(3)\n    },\n].map(c => dao.put(Candlestick.create(c)))).then(function() {\n    var E = foam.mlang.ExpressionsSingleton.create();\n    return dao.orderBy(Candlestick.CLOSE_TIME).select(E.GROUP_BY(Candlestick.KEY, E.PLOT(Candlestick.CLOSE_TIME, Candlestick.AVERAGE)));\n}).then(function(sink) {\n    return Object.keys(sink.groups).map(key => ({\n        label: key,\n        data: sink.groups[key].data.map(arr => ({ x: arr[0], y: arr[1] }))\n    }));\n}).then(function(dataset) {\n    test(dataset.length == 2, 'dataset has 2 number of items');\n    test(dataset[0].data.length == 3, 'dataset[0].data has 3 items');\n    test(dataset[1].data.length == 1, 'dataset[1].data has 1 item');\n    test(dataset[0].data[1].y == 190, 'y value set properly');\n});","output":"SUCCESS: dataset has 2 number of items\nSUCCESS: dataset[0].data has 3 items\nSUCCESS: dataset[1].data has 1 item\nSUCCESS: y value set properly\n"})
p({"class":"foam.nanos.test.Test","passed":1,"failed":0,"id":"ValidateTest","lastRun":"2019-05-07T01:03:31.645Z","lastDuration":13,"status":1,"code":"valid = new foam.nanos.auth.Phone.Builder(x).setNumber(\"123-123-1234\").build();\nvalid.validate(x);\n\ninvalid = new foam.nanos.auth.Phone.Builder(x).setNumber(\"\").build();\nthrown = false;\ntry {\n    invalid.validate(x);\n} catch (Exception e) {\n    thrown = true;\n}\ntest(thrown, \"Thrown!\");","output":"SUCCESS: Thrown!\n"})
p({ class: 'foam.nanos.auth.PreventDuplicateEmailDAOTest', id: 'PreventDuplicateEmailDAOTest' })
p({"class":"foam.nanos.test.Test","id":"Prevent privilege escalation tests","status":2,"code":"import foam.core.X;\nimport foam.dao.DAO;\nimport foam.nanos.auth.AuthService;\nimport foam.nanos.auth.AuthorizationException;\nimport foam.nanos.auth.Group;\nimport foam.nanos.auth.GroupPermissionJunction;\nimport foam.nanos.auth.Permission;\nimport foam.nanos.auth.User;\nimport foam.nanos.logger.Logger;\nimport foam.util.Auth;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nbareUserDAO = (DAO) x.get(\"bareUserDAO\");\nuserDAO = (DAO) x.get(\"userDAO\");\ngroupDAO = (DAO) x.get(\"groupDAO\");\nlocalPermissionDAO = (DAO) x.get(\"localPermissionDAO\");\npermissionDAO = (DAO) x.get(\"permissionDAO\");\ngroupPermissionJunctionDAO = (DAO) x.get(\"groupPermissionJunctionDAO\");\ntestGroup = null;\ntestUser = null;\nlogger_ = new foam.nanos.logger.PrefixLogger(new Object[] {\"PreventPriviledgeEscalation\"}, x.get(\"logger\"));\n\nString generateId() {\n  return java.util.UUID.randomUUID().toString();\n}\n\n// Generate a test user and a group with the given permissions for them to be in.\nX generateTestUser(List permissionIds) {\n  String groupId = generateId();\n  testGroup = new Group.Builder(x)\n    .setId(groupId)\n    .setParent(\"basicUser\")\n    .build();\n\n  groupDAO.where(foam.mlang.MLang.EQ(Group.ID, groupId)).removeAll();\n  groupDAO.put(testGroup);\n\n  groupPermissionJunctionDAO.where(foam.mlang.MLang.EQ(GroupPermissionJunction.SOURCE_ID, groupId)).removeAll();\n\n  for ( String id : permissionIds ) {\n    localPermissionDAO.where(foam.mlang.MLang.EQ(Permission.ID, id)).removeAll();\n    localPermissionDAO.put(new Permission.Builder(x).setId(id).build());\n    junction = new GroupPermissionJunction.Builder(x)\n      .setSourceId(groupId)\n      .setTargetId(id)\n      .build();\n    groupPermissionJunctionDAO.put(junction);\n  }\n\n  // Create a test user to sudo to.\n  bareUserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"ppet@example.com\")).removeAll();\n  testUser = new User.Builder(x)\n    .setId(999999999L)\n    .setEmail(\"ppet@example.com\")\n    .setGroup(groupId)\n    .build();\n  testUser = bareUserDAO.put(testUser);\n  return Auth.sudo(x, testUser);\n}\n\nvoid cleanUp(X testContext) {\n  // Remove the permissions.\n  groupPermissionJunctionDAO.where(foam.mlang.MLang.EQ(GroupPermissionJunction.SOURCE_ID, testGroup.id)).removeAll_(x, 0, 0, null, null);\n\n  // Remove the group.\n  groupDAO.remove_(x, testGroup);\n \n  // Remove the user.\n  bareUserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"ppet@example.com\")).removeAll();\n}\n\n// Try to create a group when you don't have the 'create' permission.\nvoid createGroupWithoutPermissionThrows() {\n  logger_.info(new Object[]{\"createGroupWithoutPermissionThrows\"});\n  // Create a group for the user to put.\n  String groupId = generateId();\n  Group g = new Group.Builder(x).setId(groupId).build();\n\n  // Create a test user.\n  List permissionIds = new ArrayList();\n  X userContext = generateTestUser(permissionIds);\n\n  try {\n    // Try to create the group.\n    g = groupDAO.inX(userContext).put(g);\n\n    // If the put didn't throw, then this test failed.\n    test(false, \"Users cannot create a group without the 'group.create.<id>' permission.\");\n\n  } catch (AuthorizationException e) {\n    test(e.getMessage().equals(\"You do not have permission to create this group.\"), \"Users cannot create a group without the 'group.create.<id>' permission.\");\n  } finally {\n    cleanUp(x);\n  }\n}\n\n// Try to add a permission you don't have to a group.\nvoid addNewPermissionThrows() {\n  logger_.info(new Object[]{\"addNewPermissionThrows\"});\n\n  // Create a test user.\n  List permissionIds = new ArrayList();\n  permissionIds.add(\"group.create.*\");\n  X userContext = generateTestUser(permissionIds);\n\n  // Create a group for the user to put.\n  Group g = new Group.Builder(x).setId(generateId()).build();\n  g = groupDAO.inX(userContext).put(g);\n\n  try {\n    // Try to add a permission to the group that the user doesn't have.\n    g.getPermissions(userContext).add(new Permission.Builder(userContext).setId(\"*\").build());\n\n    // If the put didn't throw, then this test failed.\n    test(false, \"Users cannot add a permission that they don't have to a group.\");\n\n  } catch (AuthorizationException e) {\n    test(e.getMessage().equals(\"You do not have permission to update that group.\"), \"Users cannot add a permission that they don't have to a group.\");\n  } finally {\n    cleanUp(x);\n  }\n}\n\n\n// Try to create a group with \"admin\" as the parent.\nvoid addGroupWithAdminParentThrows() {\n  logger_.info(new Object[]{\"addGroupWithAdminParentThrows\"});\n  // Create a group for the user to put.\n  String groupId = generateId();\n  Group g = new Group.Builder(x)\n    .setId(groupId)\n    .setParent(\"admin\")\n    .build();\n\n  // Create a test user.\n  List permissionIds = new ArrayList();\n  permissionIds.add(\"group.create.*\");\n  X userContext = generateTestUser(permissionIds);\n\n  try {\n    // Try to create the group.\n    g = groupDAO.inX(userContext).put(g);\n\n    // If the put didn't throw, then this test failed.\n    test(false, \"Users cannot set the parent of a group to a group containing a permission that isn't implied by one they already have.\");\n\n  } catch (AuthorizationException e) {\n    test(e.getMessage().equals(\"Permission denied. You cannot change the parent of a group if doing so grants that group permissions that you do not have.\"), \"Users cannot set the parent of a group to a group containing a permission that isn't implied by one they already have.\");\n  } finally {\n    cleanUp(x);\n  }\n}\n\n\n// Try to update a group without permission.\nvoid updateGroupWithoutPermissionThrows() {\n  logger_.info(new Object[]{\"updateGroupWithoutPermissionThrows\"});\n  // Create a group for the user to put.\n  String groupId = generateId();\n  Group g = new Group.Builder(x)\n    .setId(groupId)\n    .build();\n\n  // Create a test user.\n  List permissionIds = new ArrayList();\n  permissionIds.add(\"group.create.*\");\n  X userContext = generateTestUser(permissionIds);\n\n  // Create the group.\n  g = groupDAO.inX(userContext).put(g);\n\n  try {\n    // Try to update the group.\n    g = (Group) g.fclone();\n    g.setParent(\"basicUser\");\n    g = groupDAO.inX(userContext).put(g);\n\n    // If the put didn't throw, then this test failed.\n    test(false, \"Users cannot update groups unless they have the appropriate update permission.\");\n\n  } catch (AuthorizationException e) {\n    test(e.getMessage().equals(\"You don't have permission to update that group.\"), \"Users cannot update groups unless they have the appropriate update permission.\");\n  } finally {\n    cleanUp(x);\n  }\n}\n\n\n// Try to update a group's parent to admin.\nvoid updateGroupParentToAdminThrows() {\n  logger_.info(new Object[]{\"updateGroupParentToAdminThrows\"});\n  // Create a group for the user to put.\n  String groupId = generateId();\n  Group g = new Group.Builder(x)\n    .setId(groupId)\n    .build();\n\n  // Create a test user.\n  List permissionIds = new ArrayList();\n  permissionIds.add(\"group.create.*\");\n  permissionIds.add(\"group.update.\" + groupId);\n  X userContext = generateTestUser(permissionIds);\n\n  // Create the group.\n  g = groupDAO.inX(userContext).put(g);\n\n  try {\n    // Try to update the group's parent to admin.\n    g = (Group) g.fclone();\n    g.setParent(\"admin\");\n    g = groupDAO.inX(userContext).put(g);\n\n    // If the put didn't throw, then this test failed.\n    test(false, \"Users cannot update the parent of a group to a group containing a permission that isn't implied by one they already have.\");\n\n  } catch (AuthorizationException e) {\n    test(e.getMessage().equals(\"Permission denied. You cannot change the parent of a group if doing so grants that group permissions that you do not have.\"), \"Users cannot set the parent of a group to a group containing a permission that isn't implied by one they already have.\");\n  } finally {\n    cleanUp(x);\n  }\n}\n\n// Try to create a user in the admin group.\nvoid createUserInAdminGroupThrows() {\n  logger_.info(new Object[]{\"createUserInAdminGroupThrows\"});\n  TEST_MESSAGE = \"Users cannot create users in a group to a group containing a permission that isn't implied by one they already have.\";\n\n  // Create a user for the test user to put.\n  User u = new User.Builder(x)\n    .setGroup(\"admin\")\n    .setEmail(\"ppet+admin@example.com\")\n    .setDesiredPassword(\"!@#$ppet1234\")\n    .build();\n\n  // Create a test user.\n  List permissionIds = new ArrayList();\n  X userContext = generateTestUser(permissionIds);\n\n  try {\n    // Try to create a user in the admin group.\n    u = (User) userDAO.inX(userContext).put(u);\n    test(null == bareUserDAO.find(foam.mlang.MLang.EQ(foam.nanos.auth.User.EMAIL, \"ppet+admin@example.com\")), \"User was not created with that email address.\");\n    userDAO.remove(u);\n    \n    // If the put didn't throw, then this test failed.\n    test(false, TEST_MESSAGE);\n\n  } catch (AuthorizationException e) {\n    passed = e.getMessage().equals(\"You do not have permission to set that user's group to 'admin'.\");\n    test(passed, TEST_MESSAGE);\n    if ( ! passed ) {\n      print(\"Error message mismatch. Actual was: \" + e.getMessage());\n    }\n  } finally {\n    bareUserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"ppet+admin@example.com\")).removeAll();\n    cleanUp(x);\n  }\n}\n\n// Try to update a user's group to \"admin\".\nupdateUserGroupToAdminThrows() {\n  logger_.info(new Object[]{\"updateUserGroupToAdminThrows\"});\n  TEST_MESSAGE = \"Users cannot update another user's group to a group containing a permission that isn't implied by one they already have.\";\n\n  bareUserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"ppet1+admin@example.com\")).removeAll();\n  bareUserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"ppet2+admin@example.com\")).removeAll();\n\n  // Create a user for the test user to put.\n  User u = new User.Builder(x)\n    .setGroup(\"basicUser\")\n    .setEmail(\"ppet1+admin@example.com\")\n    .setFirstName(\"ppet\")\n    .setLastName(\"ppet\")\n    .setDesiredPassword(\"!@#$ppet1234\")\n    .build();\n\n  // Create a test user.\n  List permissionIds = new ArrayList();\n  permissionIds.add(\"group.update.basicUser\");\n  permissionIds.add(\"user.update.*\");\n  X userContext = generateTestUser(permissionIds);\n\n  // Create a user in the basicUser group.\n  u1 = userDAO.inX(userContext).put(u);\n  u2 = null;\n  try {\n    // Try to update the user's group to \"admin\".\n    u2 = (User) u1.fclone();\n    u2.setEmail(\"ppet2+admin@example.com\");\n    u2.setGroup(\"admin\");\n    u2 = userDAO.inX(userContext).put(u2);\n\n    // If the put didn't throw, then this test failed.\n    test(false, TEST_MESSAGE);\n  } catch (AuthorizationException e) {\n    passed = e.getMessage().equals(\"You do not have permission to change that user's group to 'admin'.\");\n    test(passed, TEST_MESSAGE);\n    if ( ! passed ) {\n      print(\"Error message mismatch. Actual was: \" + e.getMessage());\n    }\n  } finally {\n    userDAO.remove(u1);\n    userDAO.remove(u2);\n    cleanUp(x);\n  }\n}\n\n// Try to update your own group.\nupdateOwnGroupThrows() {\n  logger_.info(new Object[]{\"updateOwnGroupThrows\"});\n  TEST_MESSAGE = \"Users cannot update their own group.\";\n\n  // Create a test user.\n  List permissionIds = new ArrayList();\n  X userContext = generateTestUser(permissionIds);\n\n  try {\n    // Try to update the user's group to \"admin\".\n    u = (User) userContext.get(\"user\").fclone();\n    u.setGroup(\"admin\");\n    u = userDAO.inX(userContext).put(u);\n\n    // If the put didn't throw, then this test failed.\n    test(false, TEST_MESSAGE);\n  } catch (AuthorizationException e) {\n    passed = e.getMessage().equals(\"You cannot change your own group.\");\n    test(passed, TEST_MESSAGE);\n    if ( ! passed ) {\n      print(\"Error message mismatch. Actual was: \" + e.getMessage());\n    }\n  } finally {\n    cleanUp(x);\n  }\n}\n\n// Try to create a permission without permission to do so.\ncreatePermissionWithoutPermissionThrows() {\n  logger_.info(new Object[]{\"createPermissionWithoutPermissionThrows\"});\n  TEST_MESSAGE = \"Cannot create permissions without the appropriate 'create' permission.\";\n\n  // Create a test user.\n  List permissionIds = new ArrayList();\n  X userContext = generateTestUser(permissionIds);\n\n  // Create a permission for the test user to put.\n  Permission p = new Permission.Builder(x)\n    .setId(\"ppet\")\n    .build();\n\n  try {\n    // Try to create a permission.\n    p = permissionDAO.inX(userContext).put(p);\n\n    // If the put didn't throw, then this test failed.\n    test(false, TEST_MESSAGE);\n  logger_.info(new Object[]{\"createPermissionWithoutPermissionThrows\", \"FAIL\"});\n\n  } catch (AuthorizationException e) {\n    passed = e.getMessage().equals(\"Permission denied.\");\n    test(passed, TEST_MESSAGE);\n    if ( ! passed ) {\n      print(\"Error message mismatch. Actual was: \" + e.getMessage());\n    }\n  } finally {\n    cleanUp(x);\n  }\n}\n\n// Try to create a permission with permission to do so.\ncreatePermissionWithPermission() {\n  logger_.info(new Object[]{\"createPermissionWithPermission\"});\n  TEST_MESSAGE = \"Create permissions with the appropriate 'update' permission.\";\n\n  // Create a test user.\n  List permissionIds = new ArrayList();\n  permissionIds.add(\"permission.create\");\n  permissionIds.add(\"permission.update.*\"); \n  X userContext = generateTestUser(permissionIds);\n\n  // Create a permission for the test user to update.\n  Permission p = new Permission.Builder(x)\n    .setId(\"ppet\")\n    .build();\n\n  try {\n    // Create the permission.\n    p.setDescription(\"Create\");\n    p = (Permission) permissionDAO.inX(userContext).put(p).fclone();\n\n       // Update the permission.\n    p.setDescription(\"Update\");\n    p = (Permission) permissionDAO.inX(userContext).put(p).fclone();\n\n    // If the put didn't throw, then this test passed.\n    test(true, TEST_MESSAGE);\n  } catch (AuthorizationException e) {\n    passed = e.getMessage().equals(\"Permission denied.\");\n    test(false, TEST_MESSAGE);\n  } finally {\n    cleanUp(x);\n  }\n}\n\n// Try to update a permission without permission to do so.\nupdatePermissionWithoutPermissionThrows() {\n  logger_.info(new Object[]{\"updatePermissionWithoutPermissionThrows\"});\n  TEST_MESSAGE = \"Cannot update permissions without the appropriate 'update' permission.\";\n\n  // Create a test user.\n  List permissionIds = new ArrayList();\n  permissionIds.add(\"permission.create\");\n    //permissionIds.add(\"permission.update.*\");\n  X userContext = generateTestUser(permissionIds);\n\n  // Create a permission for the test user to update.\n  Permission p = new Permission.Builder(x)\n    .setId(\"ppet\")\n    .build();\n\n  permissionDAO.remove(p);\n  // Create the permission.\n  p = (Permission) permissionDAO.inX(userContext).put(p).fclone();\n\n  try {\n    // Try to update the permission.\n    p.setDescription(\"Updated\");\n    p = permissionDAO.inX(userContext).put(p);\n\n    // If the put didn't throw, then this test failed.\n    test(false, TEST_MESSAGE);\n  } catch (AuthorizationException e) {\n    passed = e.getMessage().equals(\"Permission denied.\");\n    test(passed, TEST_MESSAGE);\n    if ( ! passed ) {\n      print(\"Error message mismatch. Actual was: \" + e.getMessage());\n    }\n  } finally {\n    cleanUp(x);\n  }\n}\n\n\n// Try to delete a permission without permission to do so.\ndeletePermissionWithoutPermissionThrows() {\n  logger_.info(new Object[]{\"deletePermissionWithoutPermissionThrows\"});\n  TEST_MESSAGE = \"Cannot delete permissions without the appropriate 'delete' permission.\";\n\n  // Create a test user.\n  List permissionIds = new ArrayList();\n  permissionIds.add(\"permission.create\");\n  X userContext = generateTestUser(permissionIds);\n\n  // Create a permission for the test user to update.\n  Permission p = new Permission.Builder(x)\n    .setId(\"ppet\")\n    .build();\n  permissionDAO.remove(p);\n  \n  // Create the permission.\n  p = (Permission) permissionDAO.inX(userContext).put(p).fclone();\n\n  try {\n    // Try to delete the permission.\n    permissionDAO.inX(userContext).remove(p);\n\n    // If the put didn't throw, then this test failed.\n    test(false, TEST_MESSAGE);\n  } catch (AuthorizationException e) {\n    passed = e.getMessage().equals(\"Permission denied.\");\n    test(passed, TEST_MESSAGE);\n    if ( ! passed ) {\n      print(\"Error message mismatch. Actual was: \" + e.getMessage());\n    }\n  } finally {\n    cleanUp(x);\n  }\n}\n\n\n// Try to delete a group without permission to do so.\ndeleteGroupWithoutPermissionThrows() {\n  logger_.info(new Object[]{\"deleteGroupWithoutPermissionThrows\"});\n  TEST_MESSAGE = \"Cannot delete a group without the appropriate 'delete' permission.\";\n\n  // Create a test user.\n  List permissionIds = new ArrayList();\n  permissionIds.add(\"group.create.ppet\");\n  X userContext = generateTestUser(permissionIds);\n\n  // Create a permission for the test user to update.\n  Group g = new Group.Builder(x)\n    .setId(\"ppet\")\n    .build();\n  groupDAO.remove(g);\n  // Create the group.\n  g = (Group) groupDAO.inX(userContext).put(g).fclone();\n\n  try {\n    // Try to delete the group.\n    groupDAO.inX(userContext).remove(g);\n\n    // If the put didn't throw, then this test failed.\n    test(false, TEST_MESSAGE);\n  } catch (AuthorizationException e) {\n    passed = e.getMessage().equals(\"You don't have permission to delete that group.\");\n    test(passed, TEST_MESSAGE);\n    if ( ! passed ) {\n      print(\"Error message mismatch. Actual was: \" + e.getMessage());\n    }\n  } finally {\n    cleanUp(x);\n  }\n}\n\n\n// Try to remove a permission from a group without permission.\nremovePermissionFromGroupWithoutPermissionThrows() {\n  logger_.info(new Object[]{\"removePermissionFromGroupWithoutPermissionThrows\"});\n  TEST_MESSAGE = \"Cannot remove permissions from groups without the appropriate permissions.\";\n\n  // Create a test user.\n  List permissionIds = new ArrayList();\n  X userContext = generateTestUser(permissionIds);\n\n  try {\n    // Try to remove \"*\" from \"admin\".\n    GroupPermissionJunction j = new GroupPermissionJunction.Builder(x)\n      .setSourceId(\"admin\")\n      .setTargetId(\"*\")\n      .build();\n    groupPermissionJunctionDAO.inX(userContext).remove(j);\n\n    // If the put didn't throw, then this test failed.\n    test(false, TEST_MESSAGE);\n  } catch (AuthorizationException e) {\n    passed = e.getMessage().equals(\"You do not have permission to update that group.\");\n    test(passed, TEST_MESSAGE);\n    if ( ! passed ) {\n      print(\"Error message mismatch. Actual was: \" + e.getMessage());\n    }\n  } finally {\n    cleanUp(x);\n  }\n\n  // Do it a second time but with permission to update the group this time, but\n  // not the permission we're trying to remove. You should need both.\n\n  // Create a test user.\n  permissionIds = new ArrayList();\n  permissionIds.add(\"group.update.admin\");\n  userContext = generateTestUser(permissionIds);\n\n  try {\n    // Try to remove \"*\" from \"admin\".\n    j = new GroupPermissionJunction.Builder(x)\n      .setSourceId(\"admin\")\n      .setTargetId(\"*\")\n      .build();\n    groupPermissionJunctionDAO.inX(userContext).remove(j);\n\n    // If the put didn't throw, then this test failed.\n    test(false, TEST_MESSAGE);\n  } catch (AuthorizationException e) {\n    passed = e.getMessage().equals(\"Permission denied. You cannot add or remove a permission that you do not have.\");\n    test(passed, TEST_MESSAGE);\n    if ( ! passed ) {\n      print(\"Error message mismatch. Actual was: \" + e.getMessage());\n    }\n  } finally {\n    cleanUp(x);\n  }\n}\n\n\n// Run the tests.\ntry {\n  createGroupWithoutPermissionThrows();\n  addNewPermissionThrows();\n  addGroupWithAdminParentThrows();\n  updateGroupWithoutPermissionThrows();\n  updateGroupParentToAdminThrows();\n  createUserInAdminGroupThrows();\n  updateUserGroupToAdminThrows();\n  updateOwnGroupThrows();\n  createPermissionWithoutPermissionThrows();\n  createPermissionWithPermission();\n  updatePermissionWithoutPermissionThrows();\n  deletePermissionWithoutPermissionThrows();\n  deleteGroupWithoutPermissionThrows();\n  removePermissionFromGroupWithoutPermissionThrows();\n} catch (Throwable e) {\n  e.printStackTrace();\n  test(false, \"An unexpected exception was thrown. Some tests might not have been executed.\");\n}\n","output":""})
// Uncomment the line below when CRUNCH is mature enough to replace our current system.
// p({"class":"foam.nanos.crunch.crunchtest.CapabilityTest","id":"CapabilityTest","description":"test capability and junctions related"})
p({"class":"foam.nanos.test.Test","id":"FoldAndReduceTest","status":2,"output":""})
p({"class":"foam.nanos.test.Test","id":"FoldAndReduceTest","passed":1,"failed":1,"lastRun":"2019-06-17T19:37:11.847Z","lastDuration":90,"status":1,"output":"SUCCESS: Stock DAO has expected number of items\n\nHourly data validation\nFAILURE: Sourced file: inline evaluation of: ``import foam.nanos.test.StockSnapshot; import foam.nanos.analytics.Candlestick; i . . . '' : No static field or inner class: OPEN_TIME of class foam.nanos.analytics.Candlestick\nSourced file: inline evaluation of: ``import foam.nanos.test.StockSnapshot; import foam.nanos.analytics.Candlestick; i . . . '' : No static field or inner class: OPEN_TIME of class foam.nanos.analytics.Candlestick : at Line: 96 : in file: inline evaluation of: ``import foam.nanos.test.StockSnapshot; import foam.nanos.analytics.Candlestick; i . . . '' : Candlestick .OPEN_TIME \n\n\tat bsh.UtilEvalError.toEvalError(UtilEvalError.java:79)\n\tat bsh.UtilEvalError.toEvalError(UtilEvalError.java:84)\n\tat bsh.BSHAmbiguousName.toObject(BSHAmbiguousName.java:58)\n\tat bsh.BSHAmbiguousName.toObject(BSHAmbiguousName.java:45)\n\tat bsh.BSHPrimaryExpression.eval(BSHPrimaryExpression.java:87)\n\tat bsh.BSHPrimaryExpression.eval(BSHPrimaryExpression.java:41)\n\tat bsh.BSHArguments.getArguments(BSHArguments.java:59)\n\tat bsh.BSHMethodInvocation.eval(BSHMethodInvocation.java:63)\n\tat bsh.BSHPrimarySuffix.doSuffix(BSHPrimarySuffix.java:97)\n\tat bsh.BSHPrimaryExpression.eval(BSHPrimaryExpression.java:74)\n\tat bsh.BSHPrimaryExpression.eval(BSHPrimaryExpression.java:41)\n\tat bsh.BSHAssignment.eval(BSHAssignment.java:71)\n\tat bsh.Interpreter.eval(Interpreter.java:659)\n\tat bsh.Interpreter.eval(Interpreter.java:750)\n\tat bsh.Interpreter.eval(Interpreter.java:739)\n\tat foam.nanos.test.Test.runScript(Test.java:274)\n\tat foam.nanos.script.ScriptRunnerDAO$1.execute(ScriptRunnerDAO.java:59)\n\tat foam.nanos.pool.FixedThreadPool$ContextAgentRunnable.run(FixedThreadPool.java:42)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)\n"})
p({"class":"foam.nanos.test.Test","id":"FoldAndReduceTest","status":2,"code":"import foam.nanos.test.StockSnapshot;\nimport foam.nanos.analytics.Candlestick;\nimport static foam.mlang.MLang.*;\n\n// Setup:\n\nhourly = 60 * 60 * 1000;\ndaily = 24 * 60 * 60 * 1000;\nweekly = 7 * 24 * 60 * 60 * 1000;\n\nhourlyDAO = new foam.dao.MDAO(Candlestick.getOwnClassInfo());\ndailyDAO = new foam.dao.MDAO(Candlestick.getOwnClassInfo());\nweeklyDAO = new foam.dao.MDAO(Candlestick.getOwnClassInfo());\n\nfm = new foam.nanos.analytics.DAOFoldManager.Builder(x)\n    .setDao(hourlyDAO)\n    .setPeriodLengthMs(hourly)\n    .build();\n\nstockDAO = new foam.nanos.analytics.FoldManagerDAODecorator.Builder(x)\n    .setDelegate(new foam.dao.MDAO(StockSnapshot.getOwnClassInfo()))\n    .setFm(fm)\n    .build();\n\ndailyRm = new foam.nanos.analytics.DAOReduceManager.Builder(x)\n    .setSourceDAO(hourlyDAO)\n    .setDestDAO(dailyDAO)\n    .setPeriodLengthMs(daily)\n    .build();\n\nweeklyRm = new foam.nanos.analytics.DAOReduceManager.Builder(x)\n    .setSourceDAO(dailyDAO)\n    .setDestDAO(weeklyDAO)\n    .setPeriodLengthMs(weekly)\n    .build();\n    \n// Test data:\n    \n// First hour.\nstockDAO.put(new StockSnapshot.Builder(x)\n    .setSymbol(\"TSLA\")\n    .setTime(new Date(5))\n    .setPrice(500)\n    .build());\nstockDAO.put(new StockSnapshot.Builder(x)\n    .setSymbol(\"TSLA\")\n    .setTime(new Date(10))\n    .setPrice(650)\n    .build());\nstockDAO.put(new StockSnapshot.Builder(x)\n    .setSymbol(\"TSLA\")\n    .setTime(new Date(20))\n    .setPrice(600)\n    .build());\n\n// Second hour.\nstockDAO.put(new StockSnapshot.Builder(x)\n    .setSymbol(\"TSLA\")\n    .setTime(new Date(hourly + 5))\n    .setPrice(1000)\n    .build());\nstockDAO.put(new StockSnapshot.Builder(x)\n    .setSymbol(\"TSLA\")\n    .setTime(new Date(hourly + 10))\n    .setPrice(2000)\n    .build());\nstockDAO.put(new StockSnapshot.Builder(x)\n    .setSymbol(\"TSLA\")\n    .setTime(new Date(hourly + 20))\n    .setPrice(3000)\n    .build());\n\n// Second day.\nstockDAO.put(new StockSnapshot.Builder(x)\n    .setSymbol(\"TSLA\")\n    .setTime(new Date(daily + 5))\n    .setPrice(300)\n    .build());\nstockDAO.put(new StockSnapshot.Builder(x)\n    .setSymbol(\"TSLA\")\n    .setTime(new Date(daily+ 10))\n    .setPrice(100)\n    .build());\nstockDAO.put(new StockSnapshot.Builder(x)\n    .setSymbol(\"TSLA\")\n    .setTime(new Date(daily + 20))\n    .setPrice(200)\n    .build());\n\ntest(stockDAO.select(COUNT()).getValue() == 9,\n    \"Stock DAO has expected number of items\");\n    \nprint(\"\");\nprint(\"Hourly data validation\");\n\nhourlyData = hourlyDAO.orderBy(Candlestick.OPEN_VALUE_TIME).select().getArray();\ntest(hourlyData.size() == 3,\n    \"Hourly DAO has expected number of items\");\n\nexpected = new Candlestick.Builder(x)\n    .setKey(\"TSLA\")\n    .setCloseTime(new Date(hourly - 1))\n    .setOpen(500)\n    .setOpenValueTime(new Date(5))\n    .setClose(600)\n    .setCloseValueTime(new Date(20))\n    .setTotal(1750)\n    .setMin(500)\n    .setMax(650)\n    .setCount(3)\n    .build();\n\ndiff = expected.diff(hourlyData.get(0));\ntest(diff.keySet().size() == 0,\n    diff.keySet() + \" fields are set incorrectly\");\n\nexpected = new Candlestick.Builder(x)\n    .setKey(\"TSLA\")\n    .setCloseTime(new Date(hourly*2 - 1))\n    .setOpen(1000)\n    .setOpenValueTime(new Date(hourly+5))\n    .setClose(3000)\n    .setCloseValueTime(new Date(hourly+20))\n    .setTotal(6000)\n    .setMin(1000)\n    .setMax(3000)\n    .setCount(3)\n    .build();\n\ndiff = expected.diff(hourlyData.get(1));\ntest(diff.keySet().size() == 0,\n    diff.keySet() + \" fields are set incorrectly\");\n\nexpected = new Candlestick.Builder(x)\n    .setKey(\"TSLA\")\n    .setCloseTime(new Date(daily + hourly - 1))\n    .setOpen(300)\n    .setOpenValueTime(new Date(daily+5))\n    .setClose(200)\n    .setCloseValueTime(new Date(daily+20))\n    .setTotal(600)\n    .setMin(100)\n    .setMax(300)\n    .setCount(3)\n    .build();\n\ndiff = expected.diff(hourlyData.get(2));\ntest(diff.keySet().size() == 0,\n    diff.keySet() + \" fields are set incorrectly\");\n    \nprint(\"\");\nprint(\"Daily data validation\");\n\ndailyRm.doReduce();\n\ndailyData = dailyDAO.orderBy(Candlestick.OPEN_VALUE_TIME).select().getArray();\ntest(dailyData.size() == 2,\n    \"Daily DAO has expected number of items\");\n\nexpected = new Candlestick.Builder(x)\n    .setKey(\"TSLA\")\n    .setCloseTime(new Date(daily - 1))\n    .setOpen(500)\n    .setOpenValueTime(new Date(5))\n    .setClose(3000)\n    .setCloseValueTime(new Date(hourly+20))\n    .setTotal(7750)\n    .setMin(500)\n    .setMax(3000)\n    .setCount(6)\n    .build();\n\ndiff = expected.diff(dailyData.get(0));\ntest(diff.keySet().size() == 0,\n    diff.keySet() + \" fields are set incorrectly\");\n\nexpected = new Candlestick.Builder(x)\n    .setKey(\"TSLA\")\n    .setCloseTime(new Date(daily*2 - 1))\n    .setOpen(300)\n    .setOpenValueTime(new Date(daily+5))\n    .setClose(200)\n    .setCloseValueTime(new Date(daily+20))\n    .setTotal(600)\n    .setMin(100)\n    .setMax(300)\n    .setCount(3)\n    .build();\n\ndiff = expected.diff(dailyData.get(1));\ntest(diff.keySet().size() == 0,\n    diff.keySet() + \" fields are set incorrectly\");\n    \nprint(\"\");\nprint(\"Weekly data validation\");\n\nweeklyRm.doReduce();\n\nweeklyData = weeklyDAO.orderBy(Candlestick.OPEN_VALUE_TIME).select().getArray();\ntest(weeklyData.size() == 1,\n    \"weekly DAO has expected number of items\");\n\nexpected = new Candlestick.Builder(x)\n    .setKey(\"TSLA\")\n    .setCloseTime(new Date(weekly - 1))\n    .setOpen(500)\n    .setOpenValueTime(new Date(5))\n    .setClose(200)\n    .setCloseValueTime(new Date(daily+20))\n    .setTotal(8350)\n    .setMin(100)\n    .setMax(3000)\n    .setCount(9)\n    .build();\n\ndiff = expected.diff(weeklyData.get(0));\ntest(diff.keySet().size() == 0,\n    diff.keySet() + \" fields are set incorrectly\");\n\nprint(\"Done\");","output":""})
p({"class":"foam.nanos.test.Test","id":"FoldAndReduceTest","passed":10,"failed":0,"lastRun":"2019-06-17T19:39:02.373Z","lastDuration":80,"status":1,"output":"SUCCESS: Stock DAO has expected number of items\n\nHourly data validation\nSUCCESS: Hourly DAO has expected number of items\nSUCCESS: [] fields are set incorrectly\nSUCCESS: [] fields are set incorrectly\nSUCCESS: [] fields are set incorrectly\n\nDaily data validation\nSUCCESS: Daily DAO has expected number of items\nSUCCESS: [] fields are set incorrectly\nSUCCESS: [] fields are set incorrectly\n\nWeekly data validation\nSUCCESS: weekly DAO has expected number of items\nSUCCESS: [] fields are set incorrectly\nDone\n"})
p({"class":"foam.nanos.test.Test","id":"FoldAndReduceTest","status":2,"output":""})
p({"class":"foam.nanos.test.Test","id":"FoldAndReduceTest","lastRun":"2019-06-17T19:39:12.053Z","lastDuration":57,"status":1,"output":"SUCCESS: Stock DAO has expected number of items\n\nHourly data validation\nSUCCESS: Hourly DAO has expected number of items\nSUCCESS: [] fields are set incorrectly\nSUCCESS: [] fields are set incorrectly\nSUCCESS: [] fields are set incorrectly\n\nDaily data validation\nSUCCESS: Daily DAO has expected number of items\nSUCCESS: [] fields are set incorrectly\nSUCCESS: [] fields are set incorrectly\n\nWeekly data validation\nSUCCESS: weekly DAO has expected number of items\nSUCCESS: [] fields are set incorrectly\nDone\n"})
