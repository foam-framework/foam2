/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
  Parse combinator library.

  Create complex parsers by composing simple parsers.s

  A PStream is a "Parser Stream", the input format accepted by
  FOAM parsers.

  PStreams have the following interface:
    get int     pos   - The character position in the input stream.

    get Char    head  - The first character in the stream.

    get PStream tail  - A PStream for the next position in the input steam.

    get Object  value - 'Value' associated with this PStream.

    PStream setValue(Object value) - Create a new PStream at the same position
        but with a new 'value'. The value is used to hold the result of a
        (sub-)parse.

  PStreams are immutable, which greatly simplifies backtracking.

  A parser has the following interface:
    PStream parse(PStream stream);

  It takes as input a PStream, and returns either a PStream
  advanced to the point after all input consumed by the parser,
  or undefined if the parse failed. The value generated by the parser
  is stored in the .value property of the returned PStream.
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'StringPS',

  properties: [
    {
      name: 'str',
      class: 'Simple'
    },
    {
      name: 'pos',
      class: 'Simple'
    },
    {
      name: 'head',
      getter: function() {
        return this.str[0][this.pos];
      }
    },
    {
      name: 'tail',
      getter: function() {
        if ( ! this.instance_.tail ) {
          var ps = this.cls_.create();
          ps.str = this.str;
          ps.pos = this.pos + 1;
          this.instance_.tail = ps;
        }
        return this.instance_.tail;
      },
      setter: function(value) {
        this.instance_.tail = value;
      }
    },
    {
      name: 'value',
      setter: function(value) { this.instance_.value = value; },
      getter: function() {
        return this.instance_.value !== undefined ?
          this.instance_.value :
          this.str[0].charAt(this.pos - 1);
      }
    }
  ],

  methods: [
    function initArgs() {},

    function setValue(value) {
      // Force undefined values to null so that hasOwnProperty checks are faster.
      if ( value === undefined ) value = null;
      var ps = this.cls_.create();
      ps.str = this.str;
      ps.pos = this.pos;
      ps.tail = this.tail;
      ps.value = value;
      return ps;
    },

    function setString(s) {
      if ( ! this.pos ) this.pos = 0;
      if ( ! this.str ) this.str = [];
      this.str[0] = s;
    }
  ]
});

foam.CLASS({
  package: 'foam.parse',
  name: 'Parser',
  properties: [
    {
      name: 'parent',
      final: true
    },
    {
      class: 'Aray',
      name: 'children',
      final: true
    }
  ],
  methods: [
    function start(cls, args) {
      return this.add(this.add_(cls, args));
    },
    function add() {
      // Template method, implemented by Nary and Unary
      return this;
    },
    function add_(cls, args) {
      var p;
      if ( typeof cls === 'function' ) {
        p = cls.call(this, args);
      } else if ( typeof cls === 'string' ) {
        p = this.Literal.create({ s: p });
      } else {
        p = cls.create(args, this);
      }

      p.parent = this;

      return p;
    },
    function end() {
      return this.parent;
    },
    function parse() {
      throw "Unimplemented.";
    }
  ]
});

foam.CLASS({
  package: 'foam.parse',
  name: 'Nary',
  extends: 'foam.parse.Parser',
  properties: [
    {
      class: 'Array',
      name: 'args',
      final: true
    }
  ],
  methods: [
    function add() {
      for ( var i = 0 ; i < arguments.length ; i++ ) {
        this.args.push(this.add_(arguments[i]));
      }
      return this;
    }
  ]
});

foam.CLASS({
  package: 'foam.parse',
  name: 'Unary',
  extends: 'foam.parse.Parser',
  properties: [
    {
      name: 'delegate',
      final: true
    }
  ],
  methods: [
    function add() {
      this.delegate = this.add_(arguments[arguments.length - 1]);
      return this;
    }
  ]
});

foam.CLASS({
  package: 'foam.parse',
  name: 'Literal',
  extends: 'foam.parse.Parser',

  properties: [
    {
      name: 's',
      final: true
    },
    {
      name: 'value',
      final: true
    }
  ],

  methods: [
    function parse(ps) {
      var str = this.s;
      for ( var i = 0 ; i < str.length ; i++, ps = ps.tail ) {
        if ( str.charAt(i) !== ps.head ) {
          return undefined;
        }
      }
      return ps.setValue(this.value !== undefined ? this.value : str);
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'LiteralIC',
  extends: 'foam.parse.Parser',

  properties: [
    {
      name: 's',
      final: true,
      postSet: function(old, nu) {
        this.lower = nu.toLowerCase();
      }
    },
    {
      name: 'lower',
      final: true
    },
    {
      name: 'value',
      final: true
    }
  ],

  methods: [
    function parse(ps) {
      var str = this.lower;
      for ( var i = 0 ; i < str.length ; i++, ps = ps.tail ) {
        if ( ! ps.head || str.charAt(i) !== ps.head.toLowerCase() ) {
          return undefined;
        }
      }
      return ps.setValue(this.value !== undefined ? this.value : this.s);
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Alternate',
  extends: 'foam.parse.Nary',

  methods: [
    function parse(ps, obj) {
      // TODO(adamvy): Should we remove the obj argument in favour of
      // passing the obj along via context or something?
      var args = this.args;
      for ( var i = 0, p ; p = args[i] ; i++ ) {
        var ret = p.parse(ps, obj);
        if ( ret ) return ret;
      }
      return undefined;
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Seq',
  extends: 'foam.parse.Nary',
  methods: [
    function parse(ps, obj) {
      var ret = [];
      var args = this.args;
      for ( var i = 0, p ; p = args[i] ; i++ ) {
        if ( ! ( ps = p.parse(ps, obj) ) ) return undefined;
        ret.push(ps.value);
      }
      return ps.setValue(ret);
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'JoinValue',
  extends: 'foam.parse.Unary',
  methods: [
    function parse(ps, obj) {
      ps = this.delegate.parse(ps, obj);
      return ps ? ps.setValue(ps.value.join('')) : undefined;
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Seq1',
  extends: 'foam.parse.Parser',

  properties: [
    {
      name: 'n',
      final: true
    }
  ],

  methods: [
    function parse(ps, obj) {
      var ret;
      var args = this.args;
      var n = this.n;
      for ( var i = 0, p ; p = args[i] ; i++ ) {
        if ( ! ( ps = p.parse(ps, obj) ) ) return undefined;
        if ( i === n ) ret = ps.value;
      }
      return ps.setValue(ret);
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Optional',
  extends: 'foam.parse.Unary',

  methods: [
    function parse(ps, obj) {
      return this.delegate.parse(ps, obj) || ps.setValue(null);
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'AnyChar',
  extends: 'foam.parse.Parser',

  methods: [
    function parse(ps) {
      return ps.head ? ps.tail : undefined;
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'NotChars',
  extends: 'foam.parse.Parser',

  properties: [
    {
      name: 'chars',
      final: true
    }
  ],

  methods: [
    function parse(ps) {
      return ps.head && this.string.indexOf(ps.head) === -1 ?
        ps.tail : undefined;
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Range',
  extends: 'foam.parse.Parser',

  properties: [
    {
      name: 'from',
      final: true
    },
    {
      name: 'to',
      final: true
    }
  ],

  methods: [
    function parse(ps) {
      if ( ! ps.head ) return undefined;
      return ( this.from <= ps.head && ps.head <= this.to ) ?
          ps.tail.setValue(ps.head) :
          undefined;
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Repeat',
  extends: 'foam.parse.Unary',

  properties: [
    {
      name: 'delimiter',
      final: true
    },
    {
      class: 'Int',
      final: true,
      name: 'minimum'
    }
  ],

  methods: [
    function delim(cls, args) {
      this.start_delim(cls, args);
      return this;
    },
    function start_delim(cls, args) {
      this.delimiter = this.add_(cls, args);
      return this.delimiter;
    },
    function parse(ps, obj) {
      var ret = [];
      var p = this.p;
      var last;
      while ( ps ) {
        last = ps;
        ps = p.parse(ps, obj);
        if ( ps ) ret.push(ps.value);
        if ( this.delimiter && ps ) {
          ps = this.delimiter.parse(ps, obj) || ps;
        }
      }

      if ( this.minimum > 0 && ret.length < this.minimum ) return undefined;
      return last.setValue(ret);
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Plus',
  extends: 'foam.parse.Repeat',

  properties: [
    ['minimum', 1]
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Repeat0',
  extends: 'foam.parse.Repeat',

  methods: [
    function parse(ps, obj) {
      var res;
      var p = this.p;
      while ( res = p.parse(ps, obj) ) ps = res;
      return ps.setValue('');
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Not',
  extends: 'foam.parse.Unary',

  properties: [
    {
      name: 'else',
      final: true,
      class: 'foam.parse.ParserProperty'
    }
  ],

  methods: [
    function else(cls, args) {
      this.start_else(cls, args);
      return this;
    },
    function start_els(cls, args) {
      return this.else = this.add_(cls, args);
    },
    function parse(ps, obj) {
      return this.p.parse(ps, obj) ?
        undefined :
        (this.else ? this.else.parse(ps, obj) : ps);
    }
  ]
});

foam.CLASS({
  package: 'foam.parse',
  name: 'JSONParser',
  requires: [
    'foam.parse.Seq',
    'foam.parse.Seq0',
    'foam.parse.Seq1',
    'foam.parse.Whitespace',
    'foam.json.AnyKeyParser',
    'foam.parse.Repeat',
    'foam.parse.Optional',
    'foam.json.StringParser',
  ],
  properties: [
    'symbols',
    'cur'
  ],
  methods: [
    function map() {
      return this.
        start(this.Seq1, { index: 2 }).
          add(this.Whitespace, "{").
        start(this.Repeat).
            start(this.Seq2, { arg1: 1, arg2: 5 }).
              add(this.Whitespace, this.AnyKeyParser, this.Whitespace, ":", this.Whitespace, this.AnyValue).
            end().
          start_delim(this.Seq0).add(this.Whitespace, ",").end().
          add(this.Whitespace, "}")
        end()
    },
    function fobject() {
      return this.
        start(this.Seq1, { index: 3 }).
        add(this.Whitespace, "{", this.Whitespace).
        start(this.Seq1, { index: 4 }).
        start(this.KeyParser, { value: "class" }).end().
        add(this.Whitespace, ":", this.Whitespace, this.StringParser).
        start(this.Optional).add(",").end().
        end();
    },
    function
  ]
});

/*
TODO(adamvy):
  -detect non string values passed to StringPS.setString()
*/
