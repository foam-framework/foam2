
public interface Plan {
  public long cost();
}


public interface FindPlan
  extends Plan
{
  public FObject find(Object state, Object key);
}


public interface SelectPlan
  extends Plan
{
  public void select(Object state, Sink sink, int skip, int limit, Comparator order, Predicate predicate);
}


public interface Index {
  public Object put(Object state, FObject value);
  public Object remove(Object state, FObject value);
  public Object removeAll();
  public FindPlan planFind(Object state, Object key);
  public SelectPlan planSelect(Object state, Sink sink, int skip, int limit, Comparator order, Predicate predicate);
  public long size(Object state);

  // Future:
  // toString()
  // bulkLoad()
}


/** Have-no-plan Plan. **/
public class NoPlan
  implements FindPlan, SelectPlan
{
  protected final static NoPlan instance_ = new NoPlan();

  public static NoPlan instance() { return instance_; }

  protected NoPlan() {}

  public int cost() { return Long.MAX_VALUE; }

  public FObject find(Object state, Object key) {
    throw new IllegalStateException("Attempt to use NoPlan.");
  }

  public void select(Object state, Sink sink, int skip, int limit, Comparator order, Predicate predicate) {
    throw new IllegalStateException("Attempt to use NoPlan.");
  }
}


/** Found that no data exists for the query. **/
public class NotFoundPlan
  implements FindPlan, SelectPlan
{
  protected final static NotFoundPlan instance_ = new NotFoundPlan();

  public static NotFoundPlan instance() { return instance_; }

  protected NotFoundPlan() {}

  public int cost() { return 0; }

  public FObject find(Object state, Object key) {
    return null;
  }

  public void select(Object state, Sink sink, int skip, int limit, Comparator order, Predicate predicate) {
  }
}

public class CountPlan
  implements SelectPlan
{
  protected long count_;

  public CountPlan(long count) { count_ = count; }

  public long cost() { return 0; }

  public void select(Object state, Sink sink, int skip, int limit, Comparator order, Predicate predicate) {
    ((Count) sink).setValue(count_);
  }

  public String toString() { return "short-circuit-count(" + count_ + ")"; }
}


public class FoundFindPlan
  implements FindPlan
{
  protected FObject obj_;

  public FoundFindPlan(FObject obj) { obj_ = obj; }

  public long cost() { return 0; }

  public FObject find(Object state, Object key) { return obj_; }

  public String toString() { return "found(" + obj_.id + ")"; }
}


/** Note this class is not thread safe because ArrayList isn't thread-safe. Needs to be made safe by containment. **/
public class AltIndex
  implements Index
{

  public final static int GOOD_ENOUGH_PLAN_COST = 10;

  protected ArrayList<Index> delegates_ = new ArrayList();

  public AltIndex(Index... indices) {
    for ( int i = 0 ; i < indices ; i++ ) addIndex(indices[i]);
  }

  public AltIndex addIndex(Index i) {
    delegates_.add(i);
  }

  public Object put(Object state, FObject value) {
    Object[] oldState = (Object[]) state;
    Object[] newState = Object[state.length];

    for ( int i = 0 ; i < oldState.length ; i++ )
      newState[i] = oldState[i].put(state, value);

    return newState;
  }

  public Object remove(Object state, FObject value) {
    Object[] oldState = (Object[]) state;
    Object[] newState = Object[state.length];

    for ( int i = 0 ; i < oldState.length ; i++ )
      newState[i] = oldState[i].remove(state, value);

    return newState;
  }

  public State removeAll() {
    Object[] newState = Object[delegates_.length];

    for ( int i = 0 ; i < oldState.length ; i++ )
      newState[i] = oldState[i].removeAll();

    return newState;
  }

  public FindPlan planFind(Object state, Object key) {
    Object[] states   = (Object[]) state;
    Plan     bestPlan = NoPlan.instance();

    for ( int i = 0 ; i < delegates.length ; i++ ) {
      Plan plan = delegates[i].planFind(states[i], key);

      if ( plan.cost() < bestPlan.cost() ) {
        bestPlan = plan;
        if ( bestPlan.cost() <= GOOD_ENOUGH_PLAN_COST ) break;
      }
    }

    return bestPlan;
  }

  public SelectPlan planSelect(State state, Sink sink, int skip, int limit, Comparator order, Predicate predicate) {
    Object[] states   = (Object[]) state;
    Plan     bestPlan = NoPlan.instance();

    for ( int i = 0 ; i < delegates.length ; i++ ) {
      Plan plan = delegates[i].planSelect(states[i], sink, skip, limit, order, predicate);

      if ( plan.cost() < bestPlan.cost() ) {
        bestPlan = plan;
        if ( bestPlan.cost() <= GOOD_ENOUGH_PLAN_COST ) break;
      }
    }

    return bestPlan;
  }

  public long size(State state) {
    return delegates[0].size((Object[]) state)[0]);
  }
}
