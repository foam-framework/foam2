/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

describe('Template benchmark', function() {
  var a;

  beforeEach(function() {
    foam.CLASS({
      package: 'test',
      name: 'TemplateTest',
      templates: [
        {
          name: 'javaSource',
          template:  '// Generated by FOAM, do not modify.\n' +
            '// Version <%= this.version %><%\n' +
            '  var className       = this.javaClassName;\n' +
            "'  var parentClassName = 'AbstractFObject';\n" +
            "  var parentModel = '';\n" +
            "  if (this.extends) {\n" +
            "    parentClassName = this.extends;\n" +
            "    parentModel = this.extends + '.MODEL(), ';\n" +
            "  }\n" +
            "  if ( GLOBAL[parentClassName] && GLOBAL[parentClassName].abstract )\n" +
            "    parentClassName = 'Abstract' + parentClassName;\n" +
            "%><% if ( this.package ) { %>\n" +
            "package <%= this.package %>;\n" +
            "<% } %>\n" +
            "import foam.core.*;\n" +
            "import foam.dao.*;\n" +
            "import java.util.Arrays;\n" +
            "import java.util.List;\n" +
            "\n" +
            "public<%= this.abstract ? ' abstract' : '' %> class <%= className %>\n" +
            "    extends <%= parentClassName %> {\n" +
            "<% for ( var key in this.properties ) {\n" +
            "  var prop = this.properties[key];\n" +
            "  if ( prop.labels && prop.labels.indexOf('compiletime') != -1  )\n" +
            "    continue;\n" +
            "  javaSource.propertySource.call(this, out, prop);\n" +
            "}\n" +
            "if (this.relationships && this.relationships.length) {\n" +
            "  for ( var i = 0; i < this.relationships.length; i++) {\n" +
            "    var rel = this.relationships[i];\n" +
            "    javaSource.relationshipSource.call(this, out, rel);\n" +
            "  }\n" +
            "}\n" +
            "\n" +
            "var allProps = this.getRuntimeProperties();\n" +
            "allProps = allProps.filter(function(m) {\n" +
            "  if ( m.labels &&\n" +
            "        ( m.labels.indexOf('java') == -1 ||\n" +
            "          m.labels.indexOf(\"compiletime\") != -1 ) ) {\n" +
            "    return false;\n" +
            "  }\n" +
            "  return true;\n" +
            "});\n" +
            "\n" +
            " %>\n" +
            "final static Model model__ = new AbstractModel(<%= parentModel %>new Property[] {<% for (var i = 0; i < allProps.length; i++) { var prop = allProps[i]; %> <%= constantize(prop.name) %>,<% } %>} , new Relationship[] {<% if (this.relationships && this.relationships.length) { for (var i = 0; i < this.relationships.length; i++) { %> <%= constantize(this.relationships[i].name) %>, <% } } %> }) {\n" +
            "    public String getName() { return \"<%= this.id %>\"; }\n" +
            "    public String getShortName() { return \"<%= this.name %>\"; }\n" +
            "    public String getLabel() { return \"<%= this.label %>\"; }\n" +
            "    public Property getID() { return <%= this.ids.length ? constantize(this.ids[0]) : 'null' %>; }\n" +
            "    public FObject newInstance() { return new <%= className %>(); }\n" +
            "  };\n" +
            "\n" +
            "  public Model model() {\n" +
            "    return model__;\n" +
            "  }\n" +
            "  public static Model MODEL() {\n" +
            "    return model__;\n" +
            "  }\n" +
            "\n" +
            "  public int hashCode() {\n" +
            "    int hash = 1;\n" +
            "<% for (var i = 0; i < allProps.length; i++) { var prop = allProps[i]; %>\n" +
            "    hash = hash * 31 + hash(<%= prop.name %>_);<% } %>\n" +
            "\n" +
            "    return hash;\n" +
            "  }\n" +
            "\n" +
            "  public int compareTo(Object obj) {\n" +
            "    if ( obj == this ) return 0;\n" +
            "    if ( obj == null ) return 1;\n" +
            "\n" +
            "    <%= this.name %> other = (<%= this.name %>) obj;\n" +
            "\n" +
            "    int cmp;\n" +
            "<% for (var i = 0; i < allProps.length; i++) { var prop = allProps[i]; %>\n" +
            "    if ( ( cmp = compare(get<%= prop.name.capitalize() %>(), other.get<%= prop.name.capitalize() %>()) ) != 0 ) return cmp;<% } %>\n" +
            "\n" +
            "    return 0;\n" +
            "  }\n" +
            "\n" +
            "  public StringBuilder append(StringBuilder b) {\n" +
            "    return b<% for (var i = 0; i < allProps.length; i++) { var prop = allProps[i]; %>\n" +
            "        .append(\"<%= prop.name %>=\").append(get<%= prop.name.capitalize() %>())<%= i < allProps.length - 1 ? '.append(\", \")' : '' %><% } %>;\n" +
            "  }\n" +
            "\n" +
            "  public <%= className %> fclone() {\n" +
            "    <%= this.name %> c = new <%= this.name %>();\n" +
            "<% for (var i = 0; i < allProps.length; i++) { var prop = allProps[i]; %>\n" +
            "    c.set<%= prop.name.capitalize() %>(get<%= prop.name.capitalize() %>());<% } %>\n" +
            "    return c;\n" +
            "  }\n" +
            "<%\n" +
            "  function feature(f) {\n" +
            "    f.javaSource$f && f.javaSource$f(out, self);\n" +
            "  }\n" +
            "\n" +
            "  this.methods.forEach(feature);\n" +
            "  this.listeners.forEach(feature);\n" +
            "%>\n" +
            "}\n"
        }
      ]
    });
  });

  it('runs succesfully', function() {

  });

  it('simple template', function() {
    var f = foam.templates.TemplateUtil.create().compile(
      'hello world', 'simple', []);
    expect(f).toBeDefined();
    expect(f()).toEqual('hello world');
  });

  it('throws if given a bad template', function() {
    var t = foam.templates.TemplateUtil.create();
    // Hack: The template parser is extremely permissive, and doesn't actually
    // every fail so far as I can tell. So we override its grammar for testing.
    var oldGrammar = t.grammar;
    t.grammar = { parseString: function() { return null; } };
    expect(function() { t.compile(undefined, 'bad', []) }).toThrow();
    t.grammar = oldGrammar;
  });

  it('handles embedded newlines', function() {
    var t = foam.templates.TemplateUtil.create();
    var f = t.compile('foo\nbar', 'newlines', []);
    expect(f()).toBe('foo\nbar');
  });

  it('handles embedded code and values', function() {
    var t = foam.templates.TemplateUtil.create();
    var f = t.compile('<% var foo = "bar"; %>%%foo <%= foo %>', 'code and values', []);
    expect(typeof f).toBe('function');
    expect(f.call({ foo: 'baz' })).toBe('baz bar');
  });

  it('handles embedded single quotes', function() {
    var t = foam.templates.TemplateUtil.create();
    var f = t.compile("foo 'bar'", 'embedded quotes', []);
    expect(typeof f).toBe('function');
    expect(f()).toBe("foo 'bar'");
  });

  it('calls toString on output objects', function() {
    var t = foam.templates.TemplateUtil.create();
    var f = t.compile("%%foo", 'toString', []);
    expect(typeof f).toBe('function');
    var self = { foo: { toString: function() { return 'bar'; } } };
    expect(f.call(self)).toBe('bar');
  });

  it('handles empty output gracefully', function() {
    var o = foam.templates.TemplateOutput.create();
    expect(o.toString()).toBe('');
  });

  it('supports lazy compilation', function() {
    var t = foam.templates.TemplateUtil.create();
    var f = t.lazyCompile("%%foo", 'toString', []);
    expect(typeof f).toBe('function');
    var self = { foo: { toString: function() { return 'bar'; } } };
    expect(f.call(self)).toBe('bar');
    expect(f.call(self)).toBe('bar');
  });
});
